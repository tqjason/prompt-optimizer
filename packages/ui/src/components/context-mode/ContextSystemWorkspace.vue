<template>
    <div class="context-system-workspace" data-testid="workspace" data-mode="pro-multi">
        <div
            ref="splitRootRef"
            class="context-system-split"
            :style="{ gridTemplateColumns: `${mainSplitLeftPct}% 12px 1fr` }"
        >
            <!-- å·¦ä¾§ï¼šä¼˜åŒ–åŒºåŸŸ -->
            <div class="split-pane" style="min-width: 0; height: 100%; overflow: hidden;">
                <NFlex
                    vertical
                    :style="{ overflow: 'auto', height: '100%', minHeight: 0 }"
                    :size="12"
                >
                    <!-- ä¼šè¯ç®¡ç†å™¨ (ç³»ç»Ÿæ¨¡å¼ä¸“å±ï¼Œä¹Ÿæ˜¯æ¶ˆæ¯è¾“å…¥ç•Œé¢) -->
                    <NCard
                        :style="{ flexShrink: 0, overflow: 'auto' }"
                        content-style="padding: 0;"
                    >
                        <ConversationManager
                            :messages="conversationMessages"
                            @update:messages="handleConversationMessagesUpdated"
                            @message-change="(index, message, action) => {
                                // Pro Multiï¼šæ–°å¢/æ›´æ–°æ¶ˆæ¯åè‡ªåŠ¨é€‰ä¸­æœ€æ–°æ¶ˆæ¯ï¼Œç¡®ä¿â€œä¼˜åŒ–â€æŒ‰é’®å¯ç”¨
                                if ((action === 'add' || action === 'update') && (message.role === 'system' || message.role === 'user') && message.id) {
                                    void conversationOptimization.selectMessage(message)
                                }
                                emit('message-change', index, message, action)
                            }"
                            :available-variables="availableVariables"
                            :temporary-variables="tempVars.temporaryVariables.value"
                            :scan-variables="scanVariables"
                            :optimization-mode="optimizationMode"
                            :tool-count="toolCount"
                            @open-variable-manager="emit('open-variable-manager')"
                            @open-context-editor="handleOpenContextEditor"
                            @open-tool-manager="emit('open-tool-manager')"
                            :enable-tool-management="true"
                            :collapsible="true"
                            :max-height="300"
                            :selected-message-id="selectedMessageId"
                            :enable-message-optimization="enableMessageOptimization"
                            :is-message-optimizing="conversationOptimization.isOptimizing.value"
                            @message-select="conversationOptimization.selectMessage"
                            @optimize-message="handleOptimizeClick"
                            @variable-extracted="handleVariableExtracted"
                            @add-missing-variable="handleAddMissingVariable"
                        />
                    </NCard>

                    <!-- ä¼˜åŒ–æ§åˆ¶åŒº -->
                    <NCard :style="{ flexShrink: 0 }" size="small">
                        <NFlex vertical :size="12">
                            <!-- æ¨¡å‹å’Œæ¨¡æ¿é€‰æ‹©è¡Œ -->
                            <NFlex :size="12" :wrap="false">
                                <!-- ä¼˜åŒ–æ¨¡å‹é€‰æ‹© -->
                                <NFlex vertical :size="4" style="flex: 1">
                                    <NText :depth="3" style="font-size: 12px">
                                        {{ $t('promptOptimizer.optimizeModel') }}
                                    </NText>
                                    <SelectWithConfig
                                        v-model="selectedOptimizeModelKeyModel"
                                        :options="modelSelection.textModelOptions.value"
                                        :getPrimary="OptionAccessors.getPrimary"
                                        :getSecondary="OptionAccessors.getSecondary"
                                        :getValue="OptionAccessors.getValue"
                                        @config="handleOpenModelManager"
                                    />
                                </NFlex>

                                <!-- æ¨¡æ¿é€‰æ‹© -->
                                <NFlex vertical :size="4" style="flex: 1">
                                    <NText :depth="3" style="font-size: 12px">
                                        {{ $t('promptOptimizer.templateLabel') }}
                                    </NText>
                                    <SelectWithConfig
                                        v-model="selectedTemplateIdModel"
                                        :options="templateSelection.templateOptions.value"
                                        :getPrimary="OptionAccessors.getPrimary"
                                        :getSecondary="OptionAccessors.getSecondary"
                                        :getValue="OptionAccessors.getValue"
                                        @config="handleOpenTemplateManager"
                                    />
                                </NFlex>
                            </NFlex>

                            <!-- ä¼˜åŒ–æŒ‰é’® -->
                            <NButton
                                type="primary"
                                :loading="displayAdapter.displayedIsOptimizing.value"
                                :disabled="displayAdapter.displayedIsOptimizing.value || !selectedMessageId"
                                @click="handleOptimizeClick"
                                block
                                data-testid="pro-multi-optimize-button"
                            >
                                {{ displayAdapter.displayedIsOptimizing.value ? $t('common.loading') : $t('promptOptimizer.optimize') }}
                            </NButton>
                        </NFlex>
                    </NCard>

                    <!-- ä¼˜åŒ–ç»“æœé¢æ¿ -->
                    <NCard
                        :style="{ flex: 1, minHeight: '200px', overflow: 'hidden' }"
                        content-style="height: 100%; max-height: 100%; overflow: hidden;"
                    >
                        <template v-if="displayAdapter.isInMessageOptimizationMode.value">
                            <PromptPanelUI
                                test-id="pro-multi"
                                ref="promptPanelRef"
                                :original-prompt="displayAdapter.displayedOriginalPrompt.value"
                                :optimized-prompt="displayAdapter.displayedOptimizedPrompt.value"
                                :reasoning="optimizedReasoning"
                                :is-optimizing="displayAdapter.displayedIsOptimizing.value"
                                :is-iterating="isIterating"
                                :selected-iterate-template="selectedIterateTemplate"
                                @update:selectedIterateTemplate="emit('update:selectedIterateTemplate', $event)"
                                :versions="displayAdapter.displayedVersions.value"
                                :current-version-id="displayAdapter.displayedCurrentVersionId.value ?? undefined"
                                :show-apply-button="displayAdapter.isInMessageOptimizationMode.value"
                                 :optimization-mode="optimizationMode"
                                 :advanced-mode-enabled="true"
                                  :show-preview="true"
                                @iterate="handleIterate"
                                @openTemplateManager="handleOpenTemplateManager"
                                @switchVersion="handleSwitchVersion"
                                  @switchToV0="handleSwitchToV0"
                                  @save-favorite="emit('save-favorite', $event)"
                                  @open-preview="handleOpenPromptPreview"
                                  @apply-to-conversation="handleApplyToConversation"
                                 @apply-improvement="handleApplyImprovement"
                                 @save-local-edit="handleSaveLocalEdit"
                             />
                        </template>
                        <template v-else>
                            <NEmpty
                                data-testid="pro-multi-empty-select-message"
                                :description="t('contextMode.system.selectMessageHint')"
                                size="large"
                            />
                        </template>
                    </NCard>
                </NFlex>
            </div>

            <div
                class="split-divider"
                role="separator"
                tabindex="0"
                :aria-valuemin="25"
                :aria-valuemax="50"
                :aria-valuenow="mainSplitLeftPct"
                @pointerdown="onSplitPointerDown"
                @keydown="onSplitKeydown"
            />

            <!-- å³ä¾§ï¼šæµ‹è¯•åŒºåŸŸï¼ˆå˜é‡å…±äº« + å¤šåˆ— variantsï¼‰ -->
            <div ref="testPaneRef" class="split-pane" style="min-width: 0; height: 100%; overflow: hidden;">
                <NFlex vertical :style="{ height: '100%', gap: '12px' }">
                    <!-- å˜é‡è¡¨å•ï¼ˆå…±äº«æ‰€æœ‰åˆ—ï¼‰ -->
                    <ConversationTestPanel
                        ref="testAreaPanelRef"
                        mode="variables-only"
                        :optimization-mode="optimizationMode"
                        :global-variables="globalVariables"
                        :predefined-variables="predefinedVariables"
                        :temporary-variables="tempVars.temporaryVariables.value"
                        :input-mode="inputMode"
                        :button-size="buttonSize"
                        @variable-change="handleVariableChange"
                        @save-to-global="(name: string, value: string) => emit('save-to-global', name, value)"
                        @temporary-variable-remove="handleVariableRemove"
                        @temporary-variables-clear="handleVariablesClear"
                    />

                    <!-- é¡¶éƒ¨ï¼šåˆ—æ•°ä¸å…¨å±€æ“ä½œ -->
                    <NCard size="small" :style="{ flexShrink: 0 }">
                        <div class="test-area-top">
                            <NFlex align="center" :size="8" :wrap="false" style="min-width: 0;">
                                <NText :depth="2" class="test-area-label">
                                    {{ t('test.layout.columns') }}ï¼š
                                </NText>
                                <NRadioGroup
                                    v-model:value="testColumnCountModel"
                                    size="small"
                                    :disabled="isAnyVariantRunning"
                                >
                                    <NRadioButton :value="2">2</NRadioButton>
                                    <NRadioButton :value="3">3</NRadioButton>
                                    <NRadioButton :value="4" :disabled="!canUseFourColumns">4</NRadioButton>
                                </NRadioGroup>
                            </NFlex>

                            <NFlex align="center" justify="end" :size="8" :wrap="false">
                                <NButton
                                    type="primary"
                                    size="small"
                                    :loading="isAnyVariantRunning"
                                    :disabled="isAnyVariantRunning"
                                    @click="runAllVariants"
                                    :data-testid="'pro-multi-test-run-all'"
                                >
                                    {{ t('test.layout.runAll') }}
                                </NButton>

                                <template v-if="testColumnCountModel === 2 && hasVariantResult('a') && hasVariantResult('b')">
                                    <EvaluationScoreBadge
                                        v-if="hasCompareEvaluation || isEvaluatingCompare"
                                        :score="compareScore"
                                        :level="compareScoreLevel"
                                        :loading="isEvaluatingCompare"
                                        :result="compareEvaluationResult"
                                        type="compare"
                                        size="small"
                                        @show-detail="() => showDetail('compare')"
                                        @apply-improvement="handleApplyImprovement"
                                        @apply-patch="handleApplyLocalPatch"
                                    />
                                    <NButton
                                        v-else
                                        quaternary
                                        size="small"
                                        :disabled="isEvaluatingCompare"
                                        @click="() => handleEvaluate('compare')"
                                    >
                                        {{ t('evaluation.compareEvaluate') }}
                                    </NButton>
                                </template>
                            </NFlex>
                        </div>
                    </NCard>

                    <!-- é…ç½®åŒºï¼šä¸ç»“æœåˆ—å¯¹é½ -->
                    <NCard size="small" :style="{ flexShrink: 0 }">
                        <div class="variant-deck" :style="{ gridTemplateColumns: testGridTemplateColumns }">
                            <div v-for="id in activeVariantIds" :key="id" class="variant-cell">
                                <div class="variant-cell__controls">
                                    <NTag size="small" :bordered="false" class="variant-cell__label">
                                        {{ getVariantLabel(id) }}
                                    </NTag>
                                    <NTag
                                        v-if="isVariantStale(id)"
                                        size="small"
                                        type="warning"
                                        :bordered="false"
                                        class="variant-cell__stale"
                                    >
                                        {{ t('test.layout.stale') }}
                                    </NTag>
                                    <NSelect
                                        :value="variantVersionModels[id].value"
                                        :options="versionOptions"
                                        size="small"
                                        :disabled="variantRunning[id] || isAnyVariantRunning"
                                        :data-testid="getVariantVersionTestId(id)"
                                        @update:value="(value) => { variantVersionModels[id].value = value }"
                                        style="width: 92px"
                                    />
                                    <div class="variant-cell__model">
                                        <SelectWithConfig
                                            :data-testid="getVariantModelTestId(id)"
                                            :model-value="variantModelKeyModels[id].value"
                                            @update:model-value="(value) => { variantModelKeyModels[id].value = String(value ?? '') }"
                                            :options="modelSelection.textModelOptions.value"
                                            :getPrimary="OptionAccessors.getPrimary"
                                            :getSecondary="OptionAccessors.getSecondary"
                                            :getValue="OptionAccessors.getValue"
                                            @config="emit('config-model')"
                                            style="min-width: 0; width: 100%;"
                                        />
                                    </div>

                                    <NTooltip trigger="hover">
                                        <template #trigger>
                                            <NButton
                                                type="primary"
                                                size="small"
                                                circle
                                                :loading="variantRunning[id]"
                                                :disabled="isAnyVariantRunning && !variantRunning[id]"
                                                @click="() => runVariant(id)"
                                                :data-testid="getVariantRunTestId(id)"
                                            >
                                                <template #icon>
                                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="16" height="16">
                                                        <path d="M8 5v14l11-7z" />
                                                    </svg>
                                                </template>
                                            </NButton>
                                        </template>
                                        {{ t('test.layout.runThisColumn') }}
                                    </NTooltip>
                                </div>
                            </div>
                        </div>
                    </NCard>

                    <!-- ç»“æœåŒºï¼šå¤šåˆ—ç½‘æ ¼ï¼ˆæ— æ¨ªå‘æ»šåŠ¨ï¼‰ -->
                    <div class="variant-results-wrap">
                        <div class="variant-results" :style="{ gridTemplateColumns: testGridTemplateColumns }">
                            <NCard
                                v-for="id in activeVariantIds"
                                :key="id"
                                size="small"
                                class="variant-result-card"
                                content-style="padding: 0; height: 100%; max-height: 100%; overflow: hidden;"
                            >
                                <div class="result-container">
                                    <ToolCallDisplay
                                        v-if="variantToolCalls[id].length > 0"
                                        :tool-calls="variantToolCalls[id]"
                                        size="small"
                                        class="tool-calls-section"
                                    />

                                    <div class="result-body">
                                        <OutputDisplay
                                            :test-id="getVariantOutputTestId(id)"
                                            :content="getVariantResult(id).result"
                                            :reasoning="getVariantResult(id).reasoning"
                                            :streaming="variantRunning[id]"
                                            :enableCopy="true"
                                            :enableFullscreen="true"
                                            :enableEdit="false"
                                            :enableDiff="false"
                                            :enableFavorite="false"
                                            reasoningMode="hide"
                                            mode="readonly"
                                            :style="{ height: '100%', minHeight: '0' }"
                                        >
                                            <template #toolbar-right-extra>
                                                <div
                                                    v-if="id === 'a' && hasVariantResult('a')"
                                                    class="output-evaluation-entry"
                                                >
                                                    <EvaluationScoreBadge
                                                        v-if="hasOriginalEvaluation || isEvaluatingOriginal"
                                                        :score="originalScore"
                                                        :level="originalScoreLevel"
                                                        :loading="isEvaluatingOriginal"
                                                        :result="originalEvaluationResult"
                                                        type="original"
                                                        size="small"
                                                        @show-detail="() => showDetail('original')"
                                                        @evaluate="() => handleEvaluate('original')"
                                                        @apply-improvement="handleApplyImprovement"
                                                        @apply-patch="handleApplyLocalPatch"
                                                    />
                                                    <NButton
                                                        v-else
                                                        size="small"
                                                        quaternary
                                                        :disabled="isEvaluatingOriginal"
                                                        @click="() => handleEvaluate('original')"
                                                    >
                                                        {{ t('evaluation.evaluate') }}
                                                    </NButton>
                                                </div>

                                                <div
                                                    v-else-if="id === 'b' && hasVariantResult('b')"
                                                    class="output-evaluation-entry"
                                                >
                                                    <EvaluationScoreBadge
                                                        v-if="hasOptimizedEvaluation || isEvaluatingOptimized"
                                                        :score="optimizedScore"
                                                        :level="optimizedScoreLevel"
                                                        :loading="isEvaluatingOptimized"
                                                        :result="optimizedEvaluationResult"
                                                        type="optimized"
                                                        size="small"
                                                        @show-detail="() => showDetail('optimized')"
                                                        @evaluate="() => handleEvaluate('optimized')"
                                                        @apply-improvement="handleApplyImprovement"
                                                        @apply-patch="handleApplyLocalPatch"
                                                    />
                                                    <NButton
                                                        v-else
                                                        size="small"
                                                        quaternary
                                                        :disabled="isEvaluatingOptimized"
                                                        @click="() => handleEvaluate('optimized')"
                                                    >
                                                        {{ t('evaluation.evaluate') }}
                                                    </NButton>
                                                </div>
                                            </template>
                                        </OutputDisplay>
                                    </div>
                                </div>
                            </NCard>
                        </div>
                    </div>
                </NFlex>
            </div>
        </div>

        <EvaluationPanel
            v-model:show="evaluation.isPanelVisible.value"
            :is-evaluating="panelProps.isEvaluating"
            :result="panelProps.result"
            :stream-content="panelProps.streamContent"
            :error="panelProps.error"
            :current-type="panelProps.currentType"
            :score-level="panelProps.scoreLevel"
            @re-evaluate="evaluationHandler.handleReEvaluate"
            @apply-local-patch="handleApplyLocalPatch"
            @apply-improvement="handleApplyImprovement"
            @clear="handleClearEvaluation"
            @retry="evaluationHandler.handleReEvaluate"
        />

        <!-- å­æ¨¡å¼æœ¬åœ°é¢„è§ˆé¢æ¿ï¼šä¸å†ä¾èµ– PromptOptimizerApp çš„å…¨å±€é¢„è§ˆçŠ¶æ€ -->
        <PromptPreviewPanel
            v-model:show="showPromptPreview"
            :previewContent="previewContent"
            :missingVariables="missingVariables"
            :hasMissingVariables="hasMissingVariables"
            :variableStats="variableStats"
            :contextMode="previewContextMode"
            :renderPhase="previewRenderPhase"
        />
    </div>
</template>

<script setup lang="ts">
import {
    ref,
    reactive,
    computed,
    toRef,
    inject,
    provide,
    watch,
    onMounted,
    onUnmounted,
    type Ref,
} from 'vue'

import { useI18n } from "vue-i18n";
import {
    useProMultiMessageSession,
    type TestPanelVersionValue,
    type TestVariantConfig,
    type TestVariantId,
    type TestColumnCount,
} from '../../stores/session/useProMultiMessageSession'
import {
    NCard,
    NFlex,
    NButton,
    NText,
    NEmpty,
    NSelect,
    NRadioGroup,
    NRadioButton,
    NTooltip,
    NTag,
} from "naive-ui";
import PromptPanelUI from "../PromptPanel.vue";
import PromptPreviewPanel from "../PromptPreviewPanel.vue";
import ConversationTestPanel from "./ConversationTestPanel.vue";
import ConversationManager from "./ConversationManager.vue";
import OutputDisplay from "../OutputDisplay.vue";
import SelectWithConfig from "../SelectWithConfig.vue";
import ToolCallDisplay from "../ToolCallDisplay.vue";
import { EvaluationPanel, EvaluationScoreBadge } from '../evaluation'
import { useConversationOptimization } from '../../composables/prompt/useConversationOptimization'
import { usePromptDisplayAdapter } from '../../composables/prompt/usePromptDisplayAdapter'
import { useTemporaryVariables } from '../../composables/variable/useTemporaryVariables'
import { useEvaluationHandler, provideEvaluation, provideProContext } from '../../composables/prompt'
import { useLocalPromptPreviewPanel } from '../../composables/prompt/useLocalPromptPreviewPanel'
import { useWorkspaceModelSelection } from '../../composables/workspaces/useWorkspaceModelSelection'
import { useWorkspaceTemplateSelection } from '../../composables/workspaces/useWorkspaceTemplateSelection'
import { OptionAccessors } from '../../utils/data-transformer'
import { useToast } from "../../composables/ui/useToast";
import { useElementSize } from '@vueuse/core'
import {
    buildConversationExecutionContext,
    hashString,
    hashVariables,
} from '../../utils/prompt-variables'
import {
    applyPatchOperationsToText,
    PREDEFINED_VARIABLES,
    type ContextMode,
    type ConversationMessage,
    type ToolCall,
    type ToolCallResult,
    type OptimizationMode,
    type PromptRecord,
    type PromptRecordChain,
    type Template,
    type ToolDefinition,
    type ProSystemEvaluationContext,
    type PatchOperation,
} from "@prompt-optimizer/core";
import type { TestAreaPanelInstance } from "../types/test-area";
import type { IteratePayload, SaveFavoritePayload } from "../../types/workspace";
import type { VariableManagerHooks } from '../../composables/prompt/useVariableManager'
import type { AppServices } from '../../types/services'

interface Props {
    // æ ¸å¿ƒçŠ¶æ€
    optimizedReasoning?: string;

    // ä¼˜åŒ–çŠ¶æ€
    isOptimizing?: boolean;
    isIterating?: boolean;

    // å¤–éƒ¨çŠ¶æ€æ³¨å…¥ï¼ˆç”¨äºåˆå§‹åŒ–æœ¬åœ° hookï¼‰
    // âœ… å·²ç§»é™¤ï¼šselectedOptimizeModel, selectedTemplate, selectedIterateTemplate - ç°åœ¨ä» session store ç›´æ¥è¯»å–
    // ğŸ†• è¯„ä¼°æ¨¡å‹ï¼ˆç”¨äºè¯„ä¼°åŠŸèƒ½ï¼‰
    evaluationModelKey?: string;

    // âœ… å·²ç§»é™¤ï¼šoptimizationContext - æ”¹ä¸ºä» inject('optimizationContext') è·å–
    // âœ… å·²ç§»é™¤ï¼štoolCount - å¯ä» optimizationContextTools æ´¾ç”Ÿ

    // âœ… å·²ç§»é™¤ï¼šå˜é‡ç›¸å…³ props - æ”¹ä¸ºä» inject('variableManager') è·å–
    // globalVariables, predefinedVariables, availableVariables, scanVariables

    // âœ… å·²ç§»é™¤ï¼šenableMessageOptimization - æ¶ˆæ¯ä¼˜åŒ–åŠŸèƒ½å·²ç§»é™¤

    // å…¨å±€ä¼˜åŒ–é“¾ï¼ˆç”¨äºå†å²è®°å½•æ¢å¤ï¼‰
    versions?: PromptRecord[];
    currentVersionId?: string;

    // å“åº”å¼å¸ƒå±€é…ç½®
    inputMode?: "compact" | "normal";
    buttonSize?: "small" | "medium" | "large";
    conversationMaxHeight?: number;
    resultVerticalLayout?: boolean;

    // å¯¹æ¯”æ¨¡å¼
    isCompareMode?: boolean;

    // âœ… å·²ç§»é™¤ï¼šselectedTestModel - ç°åœ¨ä» session store ç›´æ¥è¯»å–
    /** æµ‹è¯•æ¨¡å‹åç§°ï¼ˆç”¨äºæ˜¾ç¤ºæ ‡ç­¾ï¼‰ */
    testModelName?: string;
}

interface ConversationSnapshotEntry extends ConversationMessage {
    chainId?: string;
    appliedVersion?: number;
}

interface ContextSystemHistoryPayload {
    chain: PromptRecordChain;
    record: PromptRecord;
    conversationSnapshot?: ConversationSnapshotEntry[];
    message?: ConversationMessage;
}

const props = withDefaults(defineProps<Props>(), {
    optimizedReasoning: "",
    isOptimizing: false,
    isIterating: false,
    evaluationModelKey: undefined,
    versions: () => [],
    currentVersionId: "",
    inputMode: "normal",
    buttonSize: "medium",
    conversationMaxHeight: 300,
    resultVerticalLayout: false,
    isCompareMode: false,
    testModelName: undefined,
});

// Emits å®šä¹‰
const emit = defineEmits<{
    // æ•°æ®æ›´æ–°
    (e: "update:selectedIterateTemplate", value: Template | null): void;
    (e: "update:optimizationContext", value: ConversationMessage[]): void;

    // æ“ä½œäº‹ä»¶ï¼ˆç”¨äºå†å²è®°å½•æŸ¥çœ‹åœºæ™¯ï¼‰
    (e: "test", testVariables: Record<string, string>): void;
    (e: "switch-version", version: PromptRecord): void;
    (e: "switch-to-v0", version: PromptRecord): void;
    (e: "save-favorite", data: SaveFavoritePayload): void;
    (e: "message-change", index: number, message: ConversationMessage, action: "add" | "update" | "delete"): void;

    // æ‰“å¼€é¢æ¿/ç®¡ç†å™¨
    (e: "open-variable-manager"): void;
    (e: "open-context-editor", tab?: string): void;
    (e: "open-template-manager", type?: string): void;
    (e: "open-tool-manager"): void;
    (e: "config-model"): void;

    // é¢„è§ˆç›¸å…³
    (e: "open-prompt-preview"): void;

    // å˜é‡ç®¡ç†
    (e: "variable-change", name: string, value: string): void;
    (e: "save-to-global", name: string, value: string): void;

    // ğŸ†• å¯¹æ¯”æ¨¡å¼
    (e: "update:isCompareMode", value: boolean): void;
    (e: "compare-toggle"): void;
}>();

const { t } = useI18n();
const toast = useToast();

// æ³¨å…¥æœåŠ¡å’Œå˜é‡ç®¡ç†å™¨
const injectedServices = inject<Ref<AppServices | null>>('services')
const servicesRef = injectedServices ?? ref<AppServices | null>(null)
const variableManager = inject<VariableManagerHooks | null>('variableManager', null)

// æ³¨å…¥ App å±‚ç»Ÿä¸€çš„ open* æ¥å£ï¼ˆé¿å… Pro å·¥ä½œåŒº emit é“¾æ–­å¯¼è‡´æŒ‰é’®æ— å“åº”ï¼‰
const appOpenModelManager = inject<
    ((tab?: 'text' | 'image' | 'function') => void) | null
>('openModelManager', null)
const appOpenTemplateManager = inject<((type?: string) => void) | null>(
    'openTemplateManager',
    null,
)
type ContextEditorOpenArg = ConversationMessage[] | 'messages' | 'variables' | 'tools'
const appOpenContextEditor = inject<
    ((messagesOrTab?: ContextEditorOpenArg, variables?: Record<string, string>) => void) | null
>('openContextEditor', null)

 // Pro Multi: message list is session-owned (per-submode isolation).
 // Keep emitting update:optimizationContext only as a backward-compat hook for non-App hosts.
 const proMultiSession = useProMultiMessageSession()
 const conversationMessages = computed<ConversationMessage[]>({
     get: () => proMultiSession.conversationMessagesSnapshot || [],
     set: (messages) => {
         proMultiSession.updateConversationMessages(messages)
     },
 })

 const handleConversationMessagesUpdated = (messages: ConversationMessage[]) => {
     proMultiSession.updateConversationMessages(messages)

     // If the selected message was deleted, clear selection to keep the UI consistent.
     const selectedId = proMultiSession.selectedMessageId
     if (selectedId && !messages.some((m) => m.id === selectedId)) {
         proMultiSession.selectMessage('')
     }

     emit('update:optimizationContext', messages)
 }

const handleOpenModelManager = () => {
    if (appOpenModelManager) {
        appOpenModelManager('text')
        return
    }
    emit('config-model')
}

const handleOpenTemplateManager = (typeOrPayload?: string | Record<string, unknown>) => {
    // SelectWithConfig çš„ @config å¯èƒ½ä¼šä¼ å…¥ payloadï¼ˆéå­—ç¬¦ä¸²ï¼‰ï¼Œè¿™é‡Œç»Ÿä¸€å…œåº•å¤„ç†ã€‚
    const type = typeof typeOrPayload === 'string' ? typeOrPayload : undefined
    if (appOpenTemplateManager) {
        appOpenTemplateManager(type || 'optimize')
        return
    }
    emit('open-template-manager', type)
}

const handleOpenContextEditor = (
    messages: ConversationMessage[],
    variables: Record<string, string>,
) => {
    if (appOpenContextEditor) {
        appOpenContextEditor(messages, variables)
        return
    }
    // å…œåº•ï¼šæ—§é“¾è·¯ï¼ˆå¦‚æœå®¿ä¸»ä»é€šè¿‡ emit æ‰“å¼€ç¼–è¾‘å™¨ï¼‰
    emit('open-context-editor')
}

// âœ… ä¼˜åŒ–æ¨¡å¼ï¼šå›ºå®šä¸º 'system'ï¼ˆæ­¤ç»„ä»¶ä¸“é—¨ç”¨äºç³»ç»Ÿæ¨¡å¼ä¼˜åŒ–ï¼‰
const optimizationMode: OptimizationMode = 'system';

// ğŸ†• è®¿é—®å˜é‡æ•°æ®ï¼ˆä» variableManager injectï¼‰
const globalVariables = computed(() => variableManager?.variableManager.value?.listVariables() || {})

const predefinedVariables = computed(() => {
    // ä» PREDEFINED_VARIABLES å¸¸é‡è·å–é¢„å®šä¹‰å˜é‡
    return PREDEFINED_VARIABLES.reduce((acc, name) => {
        acc[name] = variableManager?.variableManager.value?.getVariable(name) || ''
        return acc
    }, {} as Record<string, string>)
})

const availableVariables = computed(() => {
    // åˆå¹¶å…¨å±€å˜é‡å’Œé¢„å®šä¹‰å˜é‡
    return { ...globalVariables.value, ...predefinedVariables.value }
})

const scanVariables = (content: string) => {
    return variableManager?.variableManager.value?.scanVariablesInContent(content) || []
}

const toolCount = computed(() => {
    // ä» optimizationContextTools æ´¾ç”Ÿ
    return optimizationContextToolsRef.value?.length || 0
})

const enableMessageOptimization = computed(() => {
    // Pro Multiï¼šè‡ªåŠ¨é€‰ä¸­æœ€æ–°æ¶ˆæ¯è¿›è¡Œä¼˜åŒ–ï¼ˆä¸éœ€è¦æ˜¾å¼â€œé€‰æ‹©â€æŒ‰é’®ï¼‰
    // è¿™é‡Œä»éœ€å¯ç”¨â€œæ¶ˆæ¯ä¼˜åŒ–æ¨¡å¼â€ï¼Œä»¥ä¾¿ PromptPanel å±•ç¤ºä¼˜åŒ–ç»“æœåŒºã€‚
    return optimizationMode === 'system'
})

// ğŸ†• åˆå§‹åŒ–ä¸´æ—¶å˜é‡ç®¡ç†å™¨ï¼ˆä¸ ContextEditor å…±äº«ï¼‰
const tempVars = useTemporaryVariables()

// ========================
// å­æ¨¡å¼æœ¬åœ°æç¤ºè¯é¢„è§ˆï¼ˆä¸ç»è¿‡ PromptOptimizerAppï¼‰
// ========================
const previewContextMode = computed<ContextMode>(() => 'system')

// Priority: global < temporary < predefined
const previewVariables = computed<Record<string, string>>(() => ({
    ...globalVariables.value,
    ...(tempVars.temporaryVariables.value || {}),
    ...predefinedVariables.value,
}))

const {
    show: showPromptPreview,
    renderPhase: previewRenderPhase,
    previewContent,
    missingVariables,
    hasMissingVariables,
    variableStats,
    open: openPromptPreview,
} = useLocalPromptPreviewPanel(previewVariables, previewContextMode)

const handleOpenPromptPreview = () => {
    openPromptPreview(displayAdapter.displayedOptimizedPrompt.value || '', { renderPhase: 'optimize' })
}

 // ğŸ†• æµ‹è¯•ç»“æœæŒä¹…åŒ–ï¼ˆPro-systemï¼‰

// âœ¨ æ–°å¢ï¼šç›´æ¥ä½¿ç”¨ session store ç®¡ç†æ¨¡å‹å’Œæ¨¡æ¿é€‰æ‹©
const modelSelection = useWorkspaceModelSelection(servicesRef, proMultiSession)
const templateSelection = useWorkspaceTemplateSelection(
    servicesRef,
    proMultiSession,
    'conversationMessageOptimize',
    'contextIterate'
)

// ğŸ†• åˆå§‹åŒ–æœ¬åœ°ä¼šè¯ä¼˜åŒ–é€»è¾‘
 const conversationOptimization = useConversationOptimization(
     servicesRef,
     conversationMessages,
     computed(() => optimizationMode),
     modelSelection.selectedOptimizeModelKey,
     templateSelection.selectedTemplate,
     templateSelection.selectedIterateTemplate
 )

// æš´éœ²ç»™å­ç»„ä»¶ï¼ˆè™½ç„¶ç›®å‰ä¸»è¦é€šè¿‡ Props ä¼ é€’ç»™ ConversationManagerï¼Œä½†ä¿æŒ Provide ä»¥é˜²ä¸‡ä¸€ï¼‰
provide('conversationOptimization', conversationOptimization);

// ğŸ†• åˆå§‹åŒ–æ˜¾ç¤ºé€‚é…å™¨ï¼ˆæ ¹æ®æ¨¡å¼è‡ªåŠ¨åˆ‡æ¢æ•°æ®æºï¼‰
 const displayAdapter = usePromptDisplayAdapter(
     conversationOptimization,
     {
         enableMessageOptimization,
         optimizationContext: conversationMessages,
         globalVersions: computed(() => props.versions || []),
         globalCurrentVersionId: computed(() => props.currentVersionId),
         globalIsOptimizing: computed(() => props.isOptimizing),
     }
 )

// ä» inject è·å– optimizationContextToolsï¼ˆç”± App.vue æä¾›ï¼‰
const optimizationContextToolsRef = inject<Ref<ToolDefinition[]>>('optimizationContextTools', ref([]))
// ä½¿ç”¨æœ¬åœ° managed çš„ selectedMessageId
const selectedMessageId = conversationOptimization.selectedMessageId

// ğŸ”§ ä¸º SelectWithConfig çš„ v-model åˆ›å»ºè§£åŒ…çš„ computedï¼ˆé¿å… Vue prop ç±»å‹è­¦å‘Šï¼‰
const selectedOptimizeModelKeyModel = computed({
    get: () => modelSelection.selectedOptimizeModelKey.value,
    set: (value) => { modelSelection.selectedOptimizeModelKey.value = value }
})

const selectedTemplateIdModel = computed({
    get: () => templateSelection.selectedTemplateId.value,
    set: (value) => { templateSelection.selectedTemplateId.value = value }
})

const selectedIterateTemplate = computed<Template | null>({
    get: () => templateSelection.selectedIterateTemplate.value,
    set: (value) => {
        templateSelection.selectedIterateTemplateId.value = value?.id ?? ''
        templateSelection.selectedIterateTemplate.value = value ?? null
    }
})

// ğŸ†• ä» session store æ¢å¤æµ‹è¯•ç»“æœï¼ˆåªæ¢å¤ç¨³å®šå­—æ®µï¼Œä¸æ¢å¤è¿‡ç¨‹æ€ï¼‰
 onMounted(() => {
    // âœ… åˆ·æ–°æ¨¡å‹åˆ—è¡¨
    modelSelection.refreshTextModels()

     // Pro Multiï¼šåˆå§‹æ€ä¿æŒâ€œæœªé€‰æ‹©æ¶ˆæ¯â€ï¼Œè®©ç”¨æˆ·æ˜ç¡®é€‰æ‹©è¦ä¼˜åŒ–çš„æ¶ˆæ¯ã€‚
     // ä»…åœ¨ session store æœ‰é€‰ä¸­è®°å½•æ—¶å°è¯•æ¢å¤ï¼ˆåˆ·æ–°/æ¢å¤åœºæ™¯ï¼‰ã€‚
     if (proMultiSession.selectedMessageId) {
         const restored = (conversationMessages.value || []).find((m) => m.id === proMultiSession.selectedMessageId)
         if (restored) {
             void conversationOptimization.selectMessage(restored)
         } else {
             // é˜²æ­¢é€‰ä¸­ ID æŒ‡å‘å·²ä¸å­˜åœ¨çš„æ¶ˆæ¯ï¼Œå¯¼è‡´ UI è¯¯åˆ¤ä¸ºâ€œå·²é€‰ä¸­â€ã€‚
             proMultiSession.selectMessage('')
         }
     }

})

// ==================== ä¸»å¸ƒå±€ï¼šå¯æ‹–æ‹½åˆ†æ ï¼ˆå·¦ä¾§ 25%~50%ï¼‰ ====================

const splitRootRef = ref<HTMLElement | null>(null)
const testPaneRef = ref<HTMLElement | null>(null)

const clampLeftPct = (pct: number) => Math.min(50, Math.max(25, pct))

// ä½¿ç”¨æœ¬åœ° draftï¼Œé¿å…æ‹–æ‹½è¿‡ç¨‹é¢‘ç¹å†™å…¥æŒä¹…åŒ–å­˜å‚¨
const mainSplitLeftPct = ref<number>(50)
watch(
    () => proMultiSession.layout.mainSplitLeftPct,
    (pct) => {
        if (typeof pct === 'number' && Number.isFinite(pct)) {
            mainSplitLeftPct.value = clampLeftPct(Math.round(pct))
        }
    },
    { immediate: true },
)

const isDraggingSplit = ref(false)
let dragStartX = 0
let dragStartPct = 0

const handleSplitPointerMove = (e: PointerEvent) => {
    const root = splitRootRef.value
    if (!root) return
    const rect = root.getBoundingClientRect()
    if (!rect.width) return

    const deltaX = e.clientX - dragStartX
    const nextPct = dragStartPct + (deltaX / rect.width) * 100
    mainSplitLeftPct.value = clampLeftPct(nextPct)
}

const endSplitDrag = () => {
    if (!isDraggingSplit.value) return
    isDraggingSplit.value = false
    document.removeEventListener('pointermove', handleSplitPointerMove)
    document.removeEventListener('pointerup', endSplitDrag)
    document.removeEventListener('pointercancel', endSplitDrag)
    document.body.style.cursor = ''
    document.body.style.userSelect = ''

    proMultiSession.setMainSplitLeftPct(mainSplitLeftPct.value)
}

const onSplitPointerDown = (e: PointerEvent) => {
    if (!splitRootRef.value) return
    dragStartX = e.clientX
    dragStartPct = mainSplitLeftPct.value
    isDraggingSplit.value = true
    document.addEventListener('pointermove', handleSplitPointerMove)
    document.addEventListener('pointerup', endSplitDrag)
    document.addEventListener('pointercancel', endSplitDrag)
    document.body.style.cursor = 'col-resize'
    document.body.style.userSelect = 'none'
}

const onSplitKeydown = (e: KeyboardEvent) => {
    if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight' && e.key !== 'Home' && e.key !== 'End') return
    e.preventDefault()

    if (e.key === 'Home') {
        mainSplitLeftPct.value = 25
    } else if (e.key === 'End') {
        mainSplitLeftPct.value = 50
    } else {
        const delta = e.key === 'ArrowLeft' ? -1 : 1
        mainSplitLeftPct.value = clampLeftPct(mainSplitLeftPct.value + delta)
    }

    proMultiSession.setMainSplitLeftPct(mainSplitLeftPct.value)
}

onUnmounted(() => {
    endSplitDrag()
})

// ==================== æµ‹è¯•åŒºï¼šå¤šåˆ— variantsï¼ˆå½“å‰é€‰ä¸­æ¶ˆæ¯ç‰ˆæœ¬ï¼‰ ====================

const getVariant = (id: TestVariantId): TestVariantConfig | undefined => {
    const list = proMultiSession.testVariants as unknown as TestVariantConfig[]
    return Array.isArray(list) ? list.find((v) => v.id === id) : undefined
}

const testColumnCountModel = computed<TestColumnCount>({
    get: () => {
        const raw = proMultiSession.layout.testColumnCount
        return raw === 2 || raw === 3 || raw === 4 ? raw : 2
    },
    set: (value) => proMultiSession.setTestColumnCount(value),
})

const variantAVersionModel = computed<TestPanelVersionValue>({
    get: () => getVariant('a')?.version ?? 0,
    set: (value) => proMultiSession.updateTestVariant('a', { version: value }),
})

const variantBVersionModel = computed<TestPanelVersionValue>({
    get: () => getVariant('b')?.version ?? 'latest',
    set: (value) => proMultiSession.updateTestVariant('b', { version: value }),
})

const variantCVersionModel = computed<TestPanelVersionValue>({
    get: () => getVariant('c')?.version ?? 'latest',
    set: (value) => proMultiSession.updateTestVariant('c', { version: value }),
})

const variantDVersionModel = computed<TestPanelVersionValue>({
    get: () => getVariant('d')?.version ?? 'latest',
    set: (value) => proMultiSession.updateTestVariant('d', { version: value }),
})

const variantAModelKeyModel = computed<string>({
    get: () => getVariant('a')?.modelKey ?? '',
    set: (value) => proMultiSession.updateTestVariant('a', { modelKey: value }),
})

const variantBModelKeyModel = computed<string>({
    get: () => getVariant('b')?.modelKey ?? '',
    set: (value) => proMultiSession.updateTestVariant('b', { modelKey: value }),
})

const variantCModelKeyModel = computed<string>({
    get: () => getVariant('c')?.modelKey ?? '',
    set: (value) => proMultiSession.updateTestVariant('c', { modelKey: value }),
})

const variantDModelKeyModel = computed<string>({
    get: () => getVariant('d')?.modelKey ?? '',
    set: (value) => proMultiSession.updateTestVariant('d', { modelKey: value }),
})

const ALL_VARIANT_IDS: TestVariantId[] = ['a', 'b', 'c', 'd']
const activeVariantIds = computed<TestVariantId[]>(() =>
    ALL_VARIANT_IDS.slice(0, testColumnCountModel.value),
)

const variantVersionModels = {
    a: variantAVersionModel,
    b: variantBVersionModel,
    c: variantCVersionModel,
    d: variantDVersionModel,
} as const

const variantModelKeyModels = {
    a: variantAModelKeyModel,
    b: variantBModelKeyModel,
    c: variantCModelKeyModel,
    d: variantDModelKeyModel,
} as const

// pro-multi å˜é‡ä¼˜å…ˆçº§ï¼šglobal < temporary < predefined
const mergedTestVariables = computed<Record<string, string>>(() => ({
    ...globalVariables.value,
    ...(tempVars.temporaryVariables.value || {}),
    ...predefinedVariables.value,
}))

// æµ‹è¯•åŒºå®½åº¦ï¼šç”¨äºç¦ç”¨ 4 åˆ—ï¼ˆé¿å…æ¨ªå‘æ»šåŠ¨ï¼‰
const { width: testPaneWidth } = useElementSize(testPaneRef)
const canUseFourColumns = computed(() => testPaneWidth.value >= 1000)

watch(
    canUseFourColumns,
    (ok) => {
        if (!ok && testColumnCountModel.value === 4) {
            testColumnCountModel.value = 3
        }
    },
    { immediate: true },
)

const testGridTemplateColumns = computed(
    () => `repeat(${testColumnCountModel.value}, minmax(0, 1fr))`,
)

// ç‰ˆæœ¬é€‰é¡¹ï¼šä»…æ˜¾ç¤ºâ€œåŸå§‹(v0)â€ä¸â€œæœ€æ–°(latest)â€ï¼Œè‹¥å­˜åœ¨ä¸­é—´ç‰ˆæœ¬ï¼Œåˆ™é¢å¤–æ˜¾ç¤º v1..v(n-1)ã€‚
const versionOptions = computed(() => {
    const versions = conversationOptimization.currentVersions.value || []

    const sortedVersions = versions
        .map((v) => v.version)
        .filter((v): v is number => typeof v === 'number' && Number.isFinite(v) && v >= 1)
        .slice()
        .sort((a, b) => a - b)

    const latest = sortedVersions.length ? sortedVersions[sortedVersions.length - 1] : null
    const middle = latest ? sortedVersions.filter((v) => v < latest) : []

    return [
        { label: t('test.layout.original'), value: 0 },
        ...middle.map((v) => ({ label: `v${v}`, value: v })),
        { label: t('test.layout.latest'), value: 'latest' },
    ]
})

// ç¡®ä¿æµ‹è¯•åˆ—çš„æ¨¡å‹é€‰æ‹©å§‹ç»ˆæœ‰æ•ˆï¼ˆæ¨¡å‹åˆ—è¡¨å˜åŒ–æ—¶è‡ªåŠ¨ fallbackï¼‰
watch(
    () => modelSelection.textModelOptions.value,
    (opts) => {
        const fallback = opts?.[0]?.value || ''
        if (!fallback) return
        const keys = new Set((opts || []).map((o) => o.value))

        const legacy = proMultiSession.selectedTestModelKey
        const seed = legacy && keys.has(legacy) ? legacy : fallback

        for (const id of ALL_VARIANT_IDS) {
            const current = variantModelKeyModels[id].value
            if (!current || !keys.has(current)) {
                proMultiSession.updateTestVariant(id, { modelKey: seed })
            }
        }
    },
    { immediate: true },
)

type ResolvedSelectedMessage = { text: string; resolvedVersion: number }

const resolveSelectedMessageContent = (
    selection: TestPanelVersionValue,
): ResolvedSelectedMessage => {
    const selectedMsg = conversationOptimization.selectedMessage.value
    const v0 = selectedMsg?.originalContent || selectedMsg?.content || ''
    const versions = conversationOptimization.currentVersions.value || []

    const latest = versions.reduce<{ version: number; optimizedPrompt: string } | null>(
        (acc, v) => {
            if (typeof v.version !== 'number' || v.version < 1) return acc
            const next = { version: v.version, optimizedPrompt: v.optimizedPrompt || '' }
            if (!acc || next.version > acc.version) return next
            return acc
        },
        null,
    )

    if (selection === 0) {
        return { text: v0, resolvedVersion: 0 }
    }

    if (selection === 'latest') {
        if (!latest) return { text: v0, resolvedVersion: 0 }
        return { text: latest.optimizedPrompt || '', resolvedVersion: latest.version }
    }

    const target = versions.find((v) => v.version === selection)
    if (target) {
        return { text: target.optimizedPrompt || '', resolvedVersion: target.version }
    }

    if (!latest) return { text: v0, resolvedVersion: 0 }
    return { text: latest.optimizedPrompt || '', resolvedVersion: latest.version }
}

const resolvedOriginalTestPrompt = computed(() =>
    resolveSelectedMessageContent(variantAVersionModel.value),
)
const resolvedOptimizedTestPrompt = computed(() =>
    resolveSelectedMessageContent(variantBVersionModel.value),
)

// Pinia setup store ä¼šè‡ªåŠ¨è§£åŒ… refsï¼Œè¿™é‡Œæ˜¯ç›´æ¥å¯å˜çš„å“åº”å¼å¯¹è±¡ï¼ˆé Refï¼‰
const variantResults = proMultiSession.testVariantResults
const variantLastRunFingerprint = proMultiSession.testVariantLastRunFingerprint

const variantRunning = reactive<Record<TestVariantId, boolean>>({
    a: false,
    b: false,
    c: false,
    d: false,
})

const variantToolCalls = reactive<Record<TestVariantId, ToolCallResult[]>>({
    a: [],
    b: [],
    c: [],
    d: [],
})

const isAnyVariantRunning = computed(() =>
    activeVariantIds.value.some((id) => !!variantRunning[id]),
)

const getVariantLabel = (id: TestVariantId) => ({ a: 'A', b: 'B', c: 'C', d: 'D' }[id])

const getVariantVersionTestId = (id: TestVariantId) => {
    if (id === 'a') return 'pro-multi-test-original-version-select'
    if (id === 'b') return 'pro-multi-test-optimized-version-select'
    return `pro-multi-test-variant-${id}-version-select`
}

const getVariantModelTestId = (id: TestVariantId) => {
    if (id === 'a') return 'pro-multi-test-original-model-select'
    if (id === 'b') return 'pro-multi-test-optimized-model-select'
    return `pro-multi-test-variant-${id}-model-select`
}

const getVariantRunTestId = (id: TestVariantId) => `pro-multi-test-run-${id}`

const getVariantOutputTestId = (id: TestVariantId) => {
    if (id === 'a') return 'pro-multi-test-original-output'
    if (id === 'b') return 'pro-multi-test-optimized-output'
    return `pro-multi-test-variant-${id}-output`
}

const getVariantResult = (id: TestVariantId) => variantResults[id]
const hasVariantResult = (id: TestVariantId) => !!(variantResults[id]?.result || '').trim()

const formatConversationAsText = (messages: ConversationMessage[]): string => {
    if (!messages || messages.length === 0) return ''
    return messages.map((msg) => `${String(msg.role).toUpperCase()}: ${msg.content}`).join('\n\n')
}

const formatToolsAsText = (tools: ToolDefinition[]): string => {
    if (!tools || tools.length === 0) return ''
    return tools
        .map((tool) => {
            const func = tool.function
            let text = `å·¥å…·åç§°: ${func.name}`
            if (func.description) text += `\næè¿°: ${func.description}`
            if (func.parameters) text += `\nå‚æ•°ç»“æ„: ${JSON.stringify(func.parameters, null, 2)}`
            return text
        })
        .join('\n\n')
}

 const buildMessagesForSelection = (selection: TestPanelVersionValue): ConversationMessage[] => {
     const id = selectedMessageId.value
     const resolved = resolveSelectedMessageContent(selection)
     return (conversationMessages.value || []).map((msg) => ({
         ...msg,
         content: id && msg.id === id ? resolved.text : msg.content,
     }))
 }

const getVariantFingerprint = (id: TestVariantId) => {
    const selection = variantVersionModels[id].value
    const resolved = resolveSelectedMessageContent(selection)
    const modelKey = variantModelKeyModels[id].value || ''
    const tools = optimizationContextToolsRef.value || []
    const messages = buildMessagesForSelection(selection)
    const convHash = hashString(formatConversationAsText(messages))
    const toolsHash = hashString(formatToolsAsText(tools))

    const baseVars = variableManager?.allVariables.value || {}
    const conversationContext = formatConversationAsText(messages)
    const toolsContext = formatToolsAsText(tools)
    const varsHash = hashVariables({
        ...baseVars,
        ...mergedTestVariables.value,
        conversationContext,
        toolsContext,
    })

    return `${selectedMessageId.value || ''}:${String(selection)}:${resolved.resolvedVersion}:${modelKey}:${convHash}:${toolsHash}:${varsHash}`
}

const isVariantStale = (id: TestVariantId) => {
    if (!hasVariantResult(id)) return false
    const prev = variantLastRunFingerprint[id]
    if (!prev) return false
    return prev !== getVariantFingerprint(id)
}

type VariantTestInput = {
    messages: ConversationMessage[]
    modelKey: string
    resolvedVersion: number
    tools: ToolDefinition[]
    variables: Record<string, string>
}

const getVariantTestInput = (id: TestVariantId): VariantTestInput | null => {
    const modelKey = (variantModelKeyModels[id].value || '').trim()
    if (!modelKey) {
        toast.error(t('test.error.noModel'))
        return null
    }

     if (!conversationMessages.value || conversationMessages.value.length === 0) {
         toast.error(t('test.error.noConversation'))
         return null
     }

    if (!selectedMessageId.value) {
        toast.warning(t('toast.warning.messageNotFound'))
        return null
    }

    const resolved = resolveSelectedMessageContent(variantVersionModels[id].value)
    if (!resolved.text?.trim()) {
        const key = resolved.resolvedVersion === 0 ? 'test.error.noOriginalPrompt' : 'test.error.noOptimizedPrompt'
        toast.error(t(key))
        return null
    }

    const messages = buildMessagesForSelection(variantVersionModels[id].value)
    const tools = optimizationContextToolsRef.value || []

    const baseVars = variableManager?.allVariables.value || {}
    const conversationContext = formatConversationAsText(messages)
    const toolsContext = formatToolsAsText(tools)
    const variables = {
        ...baseVars,
        ...mergedTestVariables.value,
        conversationContext,
        toolsContext,
    }

    const ctx = buildConversationExecutionContext(messages, variables)
    if (ctx.forbiddenTemplateSyntax.length > 0) {
        toast.error(t('test.error.forbiddenTemplateSyntax'))
        return null
    }
    if (ctx.missingVariables.length > 0) {
        toast.error(t('test.error.missingVariables', { vars: ctx.missingVariables.join(', ') }))
        return null
    }

    return {
        messages: ctx.renderedMessages,
        modelKey,
        resolvedVersion: resolved.resolvedVersion,
        tools,
        variables,
    }
}

const runVariant = async (
    id: TestVariantId,
    opts?: {
        silentSuccess?: boolean
        silentError?: boolean
        skipClearEvaluation?: boolean
        persist?: boolean
        allowParallel?: boolean
    },
): Promise<boolean> => {
    if (variantRunning[id]) return false
    if (!opts?.allowParallel && isAnyVariantRunning.value) return false

    const promptService = servicesRef.value?.promptService
    if (!promptService) {
        toast.error(t('toast.error.serviceInit'))
        return false
    }

    const input = getVariantTestInput(id)
    if (!input) return false

    if (!opts?.skipClearEvaluation) {
        evaluationHandler.clearBeforeTest()
    }

    variantResults[id] = { result: '', reasoning: '' }
    variantToolCalls[id] = []
    variantRunning[id] = true

    try {
        await promptService.testCustomConversationStream(
            {
                modelKey: input.modelKey,
                messages: input.messages,
                variables: input.variables,
                tools: input.tools,
            },
            {
                onToken: (token: string) => {
                    const prev = variantResults[id]
                    variantResults[id] = { ...prev, result: (prev.result || '') + token }
                },
                onReasoningToken: (token: string) => {
                    const prev = variantResults[id]
                    variantResults[id] = { ...prev, reasoning: (prev.reasoning || '') + token }
                },
                onToolCall: (toolCall: ToolCall) => {
                    const toolCallResult: ToolCallResult = {
                        toolCall,
                        status: 'success',
                        timestamp: new Date(),
                    }
                    variantToolCalls[id].push(toolCallResult)
                },
                onComplete: () => {
                    // ç”± finally ç»Ÿä¸€æ”¶å°¾
                },
                onError: (error: Error) => {
                    throw error
                },
            },
        )

        if (!opts?.silentSuccess) {
            toast.success(t('toast.success.testComplete'))
        }
        return true
    } catch (_error) {
        if (!opts?.silentError) {
            toast.error(t('toast.error.testFailed'))
        }
        return false
    } finally {
        variantRunning[id] = false
        variantLastRunFingerprint[id] = getVariantFingerprint(id)
        if (opts?.persist !== false) {
            void proMultiSession.saveSession()
        }
    }
}

const runAllVariants = async () => {
    if (isAnyVariantRunning.value) return

    const ids = activeVariantIds.value
    for (const id of ids) {
        if (!getVariantTestInput(id)) return
    }

    evaluationHandler.clearBeforeTest()
    const results = await Promise.all(
        ids.map((id) =>
            runVariant(id, {
                silentSuccess: true,
                silentError: true,
                skipClearEvaluation: true,
                persist: false,
                allowParallel: true,
            }),
        ),
    )

    void proMultiSession.saveSession()

    if (results.every(Boolean)) {
        toast.success(t('toast.success.testComplete'))
    } else {
        toast.error(t('toast.error.testFailed'))
    }
}

// ğŸ†• æ„å»º Pro-System è¯„ä¼°ä¸Šä¸‹æ–‡ï¼ˆåŸºäº A/B çš„æ¶ˆæ¯ç‰ˆæœ¬ï¼‰
 const proContext = computed<ProSystemEvaluationContext | undefined>(() => {
     const selectedMsg = conversationOptimization.selectedMessage.value
     if (!selectedMsg?.id) return undefined

    const original = resolvedOriginalTestPrompt.value.text
    const optimized = resolvedOptimizedTestPrompt.value.text

     return {
         targetMessage: {
             role: selectedMsg.role as 'system' | 'user' | 'assistant' | 'tool',
             content: optimized,
             originalContent: original,
         },
         conversationMessages: (conversationMessages.value || []).map((msg) => ({
             role: msg.role,
             content: msg.id === selectedMsg.id ? optimized : msg.content,
             isTarget: msg.id === selectedMsg.id,
         })),
     }
 })

// ğŸ†• æä¾› Pro æ¨¡å¼ä¸Šä¸‹æ–‡ç»™å­ç»„ä»¶ï¼ˆå¦‚ PromptPanelï¼‰ï¼Œç”¨äºè¯„ä¼°æ—¶ä¼ é€’å¤šæ¶ˆæ¯ä¸Šä¸‹æ–‡
provideProContext(proContext)

// ğŸ†• æµ‹è¯•ç»“æœæ•°æ®ï¼ˆä»…å– A/Bï¼‰
const testResultsData = computed(() => ({
    originalResult: variantResults.a.result || undefined,
    optimizedResult: variantResults.b.result || undefined,
}))

// ğŸ†• è®¡ç®—å½“å‰è¿­ä»£éœ€æ±‚ï¼ˆç”¨äº prompt-iterate çš„ re-evaluateï¼‰
const currentIterateRequirement = computed(() => {
    const versions = displayAdapter.displayedVersions.value
    const versionId = displayAdapter.displayedCurrentVersionId.value
    if (!versions || versions.length === 0 || !versionId) return ''
    const currentVersion = versions.find((v) => v.id === versionId)
    return currentVersion?.iterationNote || ''
})

// ğŸ†• åˆå§‹åŒ–è¯„ä¼°å¤„ç†å™¨ï¼ˆä½¿ç”¨å…¨å±€ evaluation å®ä¾‹ï¼Œé¿å…åŒå¥—çŠ¶æ€ï¼‰
const evaluationHandler = useEvaluationHandler({
    services: servicesRef,
    originalPrompt: computed(() => resolvedOriginalTestPrompt.value.text),
    optimizedPrompt: computed(() => resolvedOptimizedTestPrompt.value.text),
    testContent: computed(() => ''), // Pro-Multi æ— æµ‹è¯•å†…å®¹è¾“å…¥
    testResults: testResultsData,
    evaluationModelKey: computed(() => {
        const key = props.evaluationModelKey || modelSelection.selectedOptimizeModelKey.value
        return key || ''
    }),
    functionMode: computed(() => 'pro'),
    subMode: computed(() => 'multi'),
    proContext,
    currentIterateRequirement,
    persistedResults: toRef(proMultiSession, 'evaluationResults'),
})

provideEvaluation(evaluationHandler.evaluation)

const { evaluation, handleEvaluate: handleEvaluateInternal } = evaluationHandler
const testAreaProps = evaluationHandler.testAreaEvaluationProps
const panelProps = evaluationHandler.panelProps

const isEvaluatingOriginal = computed(() => testAreaProps.value.isEvaluatingOriginal)
const isEvaluatingOptimized = computed(() => testAreaProps.value.isEvaluatingOptimized)
const originalScore = computed(() => testAreaProps.value.originalScore ?? 0)
const optimizedScore = computed(() => testAreaProps.value.optimizedScore ?? 0)
const hasOriginalEvaluation = computed(() => testAreaProps.value.hasOriginalEvaluation)
const hasOptimizedEvaluation = computed(() => testAreaProps.value.hasOptimizedEvaluation)
const originalEvaluationResult = computed(() => testAreaProps.value.originalEvaluationResult)
const optimizedEvaluationResult = computed(() => testAreaProps.value.optimizedEvaluationResult)
const originalScoreLevel = computed(() => testAreaProps.value.originalScoreLevel)
const optimizedScoreLevel = computed(() => testAreaProps.value.optimizedScoreLevel)

// å¯¹æ¯”è¯„ä¼°çŠ¶æ€
const isEvaluatingCompare = evaluationHandler.compareEvaluation.isEvaluatingCompare
const compareScore = computed(() => evaluationHandler.compareEvaluation.compareScore.value ?? 0)
const hasCompareEvaluation = evaluationHandler.compareEvaluation.hasCompareResult
const compareEvaluationResult = computed(() => evaluation.state['compare'].result)
const compareScoreLevel = computed(() =>
    evaluation.getScoreLevel(evaluationHandler.compareEvaluation.compareScore.value ?? null),
)

const handleEvaluate = async (type: 'original' | 'optimized' | 'compare') => {
    await handleEvaluateInternal(type)
}

const showDetail = (type: 'original' | 'optimized' | 'compare') => {
    evaluation.showDetail(type)
}

const handleApplyLocalPatch = (payload: { operation: PatchOperation }) => {
    if (!payload.operation) return
    const current = conversationOptimization.optimizedPrompt.value || ''
    const result = applyPatchOperationsToText(current, payload.operation)
    if (!result.ok) {
        toast.warning(t('toast.warning.patchApplyFailed'))
        return
    }

    conversationOptimization.optimizedPrompt.value = result.text
    toast.success(t('evaluation.diagnose.applyFix'))
}

const handleClearEvaluation = () => {
    evaluation.closePanel()
    evaluation.clearAllResults()
}

// Pro/multi: selected message changed => clear evaluation results
watch(selectedMessageId, (next, prev) => {
    if (next === prev) return
    handleClearEvaluation()
})

// å¤„ç†è¿­ä»£ä¼˜åŒ–äº‹ä»¶
// æ³¨æ„ï¼šç”±äº displayedOptimizedPrompt åœ¨æœªé€‰ä¸­æ¶ˆæ¯æ—¶ä¸ºç©ºï¼Œè¿­ä»£æŒ‰é’®ä¸ä¼šæ˜¾ç¤ºï¼Œæ‰€ä»¥æ­¤å‡½æ•°è°ƒç”¨æ—¶å¿…å®šå¤„äºæ¶ˆæ¯ä¼˜åŒ–æ¨¡å¼
const handleIterate = (payload: IteratePayload) => {
    conversationOptimization.iterateMessage(payload)
}

// å¤„ç†ä¼˜åŒ–ç‚¹å‡»äº‹ä»¶
// æ³¨æ„ï¼šä¼˜åŒ–æŒ‰é’®åœ¨æ²¡æœ‰é€‰ä¸­æ¶ˆæ¯æ—¶ä¼šè¢«ç¦ç”¨ï¼Œæ‰€ä»¥æ­¤å‡½æ•°è°ƒç”¨æ—¶å¿…å®šå¤„äºæ¶ˆæ¯ä¼˜åŒ–æ¨¡å¼
const handleOptimizeClick = () => {
    conversationOptimization.optimizeMessage()
}

// ğŸ†• ConversationTestPanel å¼•ç”¨
const testAreaPanelRef = ref<TestAreaPanelInstance | null>(null);

/** PromptPanel ç»„ä»¶å¼•ç”¨,ç”¨äºæ‰“å¼€è¿­ä»£å¼¹çª— */
const promptPanelRef = ref<InstanceType<typeof PromptPanelUI> | null>(null);

const isObjectRecord = (value: unknown): value is Record<string, unknown> =>
    typeof value === "object" && value !== null;

const isConversationMessage = (value: unknown): value is ConversationMessage => {
    if (!isObjectRecord(value)) return false;
    return (
        typeof value.id === "string" &&
        typeof value.role === "string" &&
        typeof value.content === "string"
    );
};

const isContextSystemHistoryPayload = (
    value: unknown,
): value is ContextSystemHistoryPayload => {
    if (!isObjectRecord(value)) return false;

    const chain = value.chain;
    const record = value.record;
    const conversationSnapshot = value.conversationSnapshot;
    const message = value.message;

    if (
        !isObjectRecord(chain) ||
        typeof chain.chainId !== "string" ||
        !Array.isArray(chain.versions)
    ) {
        return false;
    }
    if (!isObjectRecord(record) || typeof record.id !== "string") return false;
    if (conversationSnapshot !== undefined && !Array.isArray(conversationSnapshot))
        return false;
    if (message !== undefined && !isConversationMessage(message)) return false;

    return true;
};

const restoreFromHistory = async (payload: unknown) => {
    if (!isContextSystemHistoryPayload(payload)) {
        console.warn(
            "[ContextSystemWorkspace] Invalid history payload, ignored:",
            payload,
        );
        return;
    }

    const { chain, record, conversationSnapshot, message } = payload;
    try {
        if (conversationSnapshot?.length) {
            let mappingCount = 0;
            conversationSnapshot.forEach((snapshotMsg) => {
                if (snapshotMsg.id && snapshotMsg.chainId) {
                    // ğŸ”§ Codex ä¿®å¤ï¼šä½¿ç”¨çº¯ messageId ä½œä¸º keyï¼Œä¸ useConversationOptimization ç»Ÿä¸€
                    conversationOptimization.messageChainMap.value.set(
                        snapshotMsg.id,
                        snapshotMsg.chainId,
                    );
                    mappingCount += 1;
                }
            });
            if (mappingCount > 0) {
                console.log(
                    `[ContextSystemWorkspace] å·²é‡å»º ${mappingCount} ä¸ªæ¶ˆæ¯çš„ä¼˜åŒ–é“¾æ˜ å°„å…³ç³»`,
                );
            }
        }

        if (!message) {
            return;
        }

        await conversationOptimization.selectMessage(message);
        conversationOptimization.currentChainId.value = chain.chainId;
        conversationOptimization.currentVersions.value = chain.versions;
        conversationOptimization.currentRecordId.value = record.id;
        conversationOptimization.optimizedPrompt.value = record.optimizedPrompt;
    } catch (error) {
        console.error('[ContextSystemWorkspace] å†å²è®°å½•æ¢å¤å¤±è´¥:', error);
        // é”™è¯¯ä¼šå‘ä¸Šä¼ æ’­åˆ° App.vue çš„ handleHistoryReuse ä¸­ç»Ÿä¸€å¤„ç†
        throw error;
    }
};

// ğŸ†• å¤„ç†ç‰ˆæœ¬åˆ‡æ¢
const handleSwitchVersion = (version: PromptRecord) => {
    if (displayAdapter.isInMessageOptimizationMode.value) {
        conversationOptimization.switchVersion(version);
    } else {
        emit('switch-version', version);
    }
};

// ğŸ†• å¤„ç† V0 åˆ‡æ¢
const handleSwitchToV0 = (version: PromptRecord) => {
    if (displayAdapter.isInMessageOptimizationMode.value) {
        conversationOptimization.switchToV0(version);
    } else {
        emit('switch-to-v0', version);
    }
};

const handleApplyToConversation = () => {
    if (!displayAdapter.isInMessageOptimizationMode.value) return;
    conversationOptimization.applyCurrentVersion();
};

// ğŸ†• å¤„ç†å˜é‡æå–
// æ³¨æ„ï¼štoast å·²åœ¨ VariableAwareInput ä¸­æ˜¾ç¤ºï¼Œè¿™é‡Œä¸é‡å¤ï¼ˆå‚è€ƒ ContextUserWorkspace çš„å®ç°ï¼‰
const handleVariableExtracted = (data: {
    variableName: string;
    variableValue: string;
    variableType: "global" | "temporary";
}) => {
    if (data.variableType === "global") {
        variableManager?.addVariable(data.variableName, data.variableValue);
    } else {
        tempVars.setVariable(data.variableName, data.variableValue);
    }
};

// ğŸ†• å¤„ç†æ·»åŠ ç¼ºå¤±å˜é‡
// æ³¨æ„ï¼štoast å·²åœ¨ VariableAwareInput ä¸­æ˜¾ç¤ºï¼Œè¿™é‡Œä¸é‡å¤ï¼ˆå‚è€ƒ ContextUserWorkspace çš„å®ç°ï¼‰
const handleAddMissingVariable = (varName: string) => {
    tempVars.setVariable(varName, "");
};

// ğŸ†• å¤„ç†ä¸´æ—¶å˜é‡å˜æ›´
const handleVariableChange = (name: string, value: string) => {
    tempVars.setVariable(name, value);
    emit('variable-change', name, value);
};

// ğŸ†• å¤„ç†ä¸´æ—¶å˜é‡ç§»é™¤
const handleVariableRemove = (name: string) => {
    tempVars.deleteVariable(name);
    emit('variable-change', name, '');
};

// ğŸ†• å¤„ç†æ¸…ç©ºæ‰€æœ‰ä¸´æ—¶å˜é‡
const handleVariablesClear = () => {
    const removedNames = Object.keys(tempVars.temporaryVariables.value);
    tempVars.clearAll();
    removedNames.forEach(name => emit('variable-change', name, ''));
};

// ğŸ†• å¤„ç†åº”ç”¨æ”¹è¿›å»ºè®®äº‹ä»¶ï¼ˆä½¿ç”¨ evaluationHandler æä¾›çš„å·¥å‚æ–¹æ³•ï¼‰
const handleApplyImprovement = evaluationHandler.createApplyImprovementHandler(promptPanelRef);

// å¤„ç†ä¿å­˜æœ¬åœ°ç¼–è¾‘
const handleSaveLocalEdit = async (payload: { note?: string }) => {
    await conversationOptimization.saveLocalEdit({
        optimizedPrompt: conversationOptimization.optimizedPrompt.value || '',
        note: payload.note,
        source: 'manual',
    });
};

// æš´éœ²å¼•ç”¨
defineExpose({
    testAreaPanelRef,
    restoreFromHistory,
    openIterateDialog: (initialContent?: string) => {
        promptPanelRef.value?.openIterateDialog?.(initialContent);
    },
    applyLocalPatch: (operation: PatchOperation) => {
        handleApplyLocalPatch({ operation })
    },
    reEvaluateActive: async () => {
        await evaluationHandler.handleReEvaluate();
    },
    // ğŸ”§ Codex ä¿®å¤ï¼šæš´éœ² session store æ¢å¤æ–¹æ³•ï¼Œä¾›çˆ¶ç»„ä»¶åœ¨ session restore å®Œæˆåè°ƒç”¨
    restoreConversationOptimizationFromSession: () => {
        conversationOptimization.restoreFromSessionStore();
    },
});
</script>

<style scoped>
.context-system-workspace {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    flex: 1;
    min-height: 0;
    overflow: hidden;
}

.context-system-split {
    display: grid;
    width: 100%;
    height: 100%;
    min-height: 0;
    overflow: hidden;
}

.split-pane {
    min-height: 0;
}

.split-divider {
    cursor: col-resize;
    background: var(--n-divider-color, rgba(0, 0, 0, 0.08));
    border-radius: 999px;
    margin: 6px 0;
    transition: background 120ms ease;
}

.split-divider:hover,
.split-divider:focus-visible {
    background: var(--n-primary-color, rgba(59, 130, 246, 0.5));
    outline: none;
}

.test-area-top {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 12px;
    width: 100%;
}

.test-area-label {
    white-space: nowrap;
}

.variant-deck {
    display: grid;
    gap: 12px;
    width: 100%;
}

.variant-cell {
    min-width: 0;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.variant-cell__controls {
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 0;
}

.variant-cell__label {
    flex-shrink: 0;
}

.variant-cell__stale {
    flex-shrink: 0;
}

.variant-cell__model {
    /* è®©æ¨¡å‹é€‰æ‹©ä¸è¦æ— é™æ‹‰ä¼¸ï¼šä¿æŒç´§å‡‘ï¼Œé¿å…æŠŠå³ä¾§æŒ‰é’®/å¸ƒå±€æŒ¤æ•£ */
    flex: 0 1 220px;
    max-width: 220px;
    min-width: 0;
}

.output-evaluation-entry {
    display: flex;
    align-items: center;
    white-space: nowrap;
}

.variant-results-wrap {
    flex: 1;
    min-height: 0;
    overflow: hidden;
}

.variant-results {
    display: grid;
    gap: 12px;
    height: 100%;
    min-height: 0;
}

.variant-result-card {
    height: 100%;
    min-height: 0;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.variant-result-card :deep(.n-card__content) {
    height: 100%;
    max-height: 100%;
    overflow: hidden;
}

.result-container {
    height: 100%;
    display: flex;
    flex-direction: column;
    min-height: 0;
}

.result-body {
    flex: 1;
    min-height: 0;
    overflow: auto;
}

.tool-calls-section {
    flex: 0 0 auto;
}
</style>
